# Custom RxJava

## Введение
Реактивное программирование — это парадигма, которая позволяет обрабатывать асинхронные потоки 
данных или событий. Она особенно полезна для управления сложными асинхронными операциями, делая их 
более удобными и компонуемыми. RxJava — популярная библиотека на Java, реализующая принципы реактивного 
программирования, предоставляя инструменты для создания и обработки асинхронных потоков событий.

В рамках данного проекта была реализована упрощённая версия RxJava, чтобы изучить основные 
концепции реактивного программирования, включая Observable, Observer, Disposable, операторы 
и Scheduler. Реализация включает базовые компоненты реактивного потока, поддержку асинхронного 
выполнения, обработку ошибок и операторы преобразования данных.

## 1. Описание архитектуры
Архитектура реализованной системы основана на паттерне «Наблюдатель» (Observer pattern) и включает 
три ключевых компонента: Observable, Observer и Disposable, а также поддержку операторов и Schedulers 
для управления потоками выполнения.
### Компоненты системы
- Observable: Представляет источник данных или событий. Создаётся с помощью статического метода `create`, 
который принимает реализацию интерфейса ObservableOnSubscribe<T>. Этот интерфейс определяет метод 
`subscribe`, где происходит эмиссия данных (вызовы `onNext`, `onError` или `onComplete` на наблюдателе). 
Observable обеспечивает поток данных, который может быть преобразован с помощью операторов, таких 
как `map`, `filter` и `flatMap`.
- Observer: Интерфейс, определяющий методы для обработки событий от Observable:
  - `onNext(T item)`: вызывается при получении нового элемента.
  - `onError(Throwable t)`: вызывается при возникновении ошибки.
  - `onComplete()`: вызывается при завершении потока.

  Наблюдатель подписывается на Observable, чтобы получать и обрабатывать его события.
- Disposable: Интерфейс для управления подпиской. Содержит методы `dispose()` для отмены подписки и 
`isDisposed()` для проверки состояния. Disposable позволяет наблюдателю прервать получение данных, что 
важно для предотвращения утечек ресурсов.
### Механизм подписки
Когда наблюдатель подписывается на Observable с помощью метода `subscribe`, создаётся объект DisposableImpl, 
который управляет жизненным циклом подписки. Внутри метода `subscribe` наблюдатель оборачивается в дополнительный 
слой, который проверяет, не была ли подписка отменена (`isDisposed`) и не завершён ли поток (через флаг `terminated`). 
Это гарантирует, что эмиссия данных происходит только в активной подписке и до завершения потока.
### Операторы
Реализованы следующие операторы преобразования данных:
- map: Преобразует каждый элемент потока с помощью заданной функции.
- filter: Пропускает только те элементы, которые удовлетворяют заданному условию.
- flatMap: Преобразует элементы в новые Observables и объединяет их эмиссии в один поток.

Каждый оператор создаёт новый Observable, который оборачивает исходный, применяя соответствующее преобразование. 
Например, в `flatMap` каждый элемент преобразуется в новый Observable, на который подписывается система, а его 
эмиссии передаются внешнему наблюдателю.

### Управление потоками
Методы `subscribeOn` и `observeOn` позволяют управлять потоками выполнения:
- `subscribeOn`: Определяет Scheduler, на котором выполняется подписка и эмиссия данных.
- `observeOn`: Определяет Scheduler, на котором вызываются методы наблюдателя (`onNext`, `onError`, `onComplete`).

Эти методы используют Schedulers для выполнения операций в разных потоках, что обеспечивает асинхронность и гибкость.

## 2. Принципы работ
Schedulers в реактивном программировании определяют контекст выполнения операций, то есть поток, 
в котором выполняются определённые части реактивной цепочки. Они позволяют разделить выполнение эмиссии данных и 
обработку событий, что особенно важно для асинхронных приложений.ы Schedulers
### Реализованные Schedulers
В проекте реализованы три типа Schedulers, каждый из которых использует пул потоков из java.util.concurrent.ExecutorService:

|Scheduler	|Описание	|Область применения|
|-----------|---------|------------------|
|IOThreadScheduler	|Использует кэширующий пул потоков (Executors.newCachedThreadPool).	|Операции ввода-вывода (сетевые запросы, работа с файлами).|
|ComputationScheduler	|Использует фиксированный пул потоков с количеством потоков, равным числу процессоров.	|Вычислительно интенсивные задачи (сложные расчёты).|
|SingleThreadScheduler	|Использует однопоточный исполнитель (Executors.newSingleThreadExecutor).	|Последовательные задачи, требующие строгого порядка выполнения.|
### Различия и применение
- subscribeOn: Задаёт Scheduler для выполнения подписки и эмиссии данных. Например, если Observable выполняет сетевой запрос, `subscribeOn(new IOThreadScheduler())` обеспечит выполнение этого запроса в потоке ввода-вывода.
- observeOn: Задаёт Scheduler для обработки событий наблюдателем. Например, `observeOn(new ComputationScheduler())` может использоваться для выполнения вычислений над полученными данными в отдельном потоке.

Эти механизмы позволяют гибко управлять потоками выполнения, разделяя, например, выполнение сетевых операций и обработку результатов.

## 3. Процесс тестирования
Процесс тестирования включает набор юнит-тестов, проверяющих ключевые аспекты функциональности системы. Тесты реализованы с использованием JUnit и охватывают следующие сценарии:
|Тест	|Описание|
|-----|--------|
testCreateAndSubscribe|	Проверяет корректность создания Observable и эмиссии элементов с завершением.
testErrorHandling|	Проверяет правильную обработку ошибок и их передачу наблюдателю.
testNoEmissionAfterComplete|	Убеждается, что после завершения потока эмиссия элементов прекращается.
testMap|	Проверяет преобразование элементов с помощью оператора `map`.
testFilter|	Проверяет фильтрацию элементов с помощью оператора `filter`.
testFlatMap|	Проверяет преобразование элементов в новые Observables и их объединение.
testDisposable|	Проверяет, что отмена подписки через Disposable останавливает эмиссию.
testSubscribeOn|	Проверяет выполнение подписки на указанном Scheduler.
testObserveOn|	Проверяет вызов методов наблюдателя на указанном Scheduler.
testOperatorChain|	Проверяет корректность цепочки операторов (`filter` и `map`).

Эти тесты подтверждают, что система корректно обрабатывает асинхронные операции, преобразования данных и управление потоками выполнения. Каждый тест проверяет отдельный аспект функциональности, обеспечивая 
полное покрытие основных возможностей библиотеки.
## 4. Примеры использования
### 1) Асинхронное получение и обработка данных
**Сценарий**: Веб-приложение или серверное приложение, которое выполняет запросы к нескольким API для получения данных, 
обрабатывает их и возвращает результат клиенту. Реактивный подход позволяет выполнять запросы параллельно, не блокируя основной поток, и обрабатывать результаты в нужном потоке.

**Почему эффективно**: Использование subscribeOn с IOThreadScheduler позволяет выполнять сетевые запросы в фоновых потоках, 
а observeOn с SingleThreadScheduler (или аналогичным для UI) обеспечивает обновление интерфейса в основном потоке. Оператор flatMap позволяет компоновать результаты из нескольких источников.

### 2) Обработка данных в реальном времени
**Сценарий**: Система, которая получает поток данных от сенсоров, логов или других источников в реальном времени, фильтрует их и выполняет преобразования, такие как агрегация или нормализация.

**Почему эффективно**: Операторы filter и map позволяют обрабатывать данные по мере их поступления, а Disposable обеспечивает возможность остановки обработки при необходимости. Это минимизирует использование ресурсов и упрощает управление потоками данных.
### 3) Управление событиями пользовательского интерфейса
**Сценарий**: Мобильное или веб-приложение, где пользовательские действия, такие как клики по кнопкам или ввод текста, инициируют асинхронные операции, например, поиск или загрузку данных.

**Почему эффективно**: Библиотека позволяет обрабатывать события асинхронно, не блокируя интерфейс, и обновлять UI в нужном потоке. Операторы упрощают обработку событий, а Disposable позволяет управлять жизненным циклом подписок.
## Заключение
Реализованная версия RxJava предоставляет основу для понимания концепций реактивного программирования. Реализация включает ключевые компоненты 
(Observable, Observer, Disposable), операторы (`map`, `filter`, `flatMap`) и Schedulers для управления потоками выполнения. Тесты подтверждают 
корректность работы системы, а примеры использования иллюстрируют её практическое применение. Эта библиотека демонстрирует, как можно создавать и 
обрабатывать асинхронные потоки данных, обеспечивая гибкость и масштабируемость.
